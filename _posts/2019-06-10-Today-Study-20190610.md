# 抽象类和接口的区别

1. 修饰符角度：接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的
2. 子类/接口实现类的实现角度：实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。
3. 继承机制角度：接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用. 

> 接口是常量值和方法定义的集合。接口是一种特殊的抽象类。
>
> ```
> java类是单继承的。classB Extends classA
> java接口可以多继承。Interface3 Extends Interface0, Interface1, ``interface``……
> ```
>
>  不允许类多重继承的主要原因是，如果A同时继承B和C，而b和c同时有一个D方法，A如何决定该继承那一个呢？
>
> 但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。

**抽象类一般作为公共的父类为子类的扩展提供基础，这里的扩展包括了属性上和行为(方法)上的。而接口一般来说不考虑属性，只考虑方法，使得子类可以自由的填补或者扩展接口所定义的方法**



# JVM类加载机制和加载器(ClassLoader)

这是看到的博客地址，详细可以看看

 [CSDN博客_JVM类加载机制和加载器](https://blog.csdn.net/m0_38075425/article/details/81627349)

下面我挑着总结一下：

当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化

## 类加载过程

1. 加载
2. 链接
3. 初始化

## 类加载时机：

1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.nobt.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类

## 类加载器：

类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。

 JVM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器

1. 根类加载器
2. 扩展类加载器
3. 系统类加载器

## 类加载机制：

**JVM的类加载机制**主要有如下3种：

1. 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。

2. 双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。

   这里还有一篇博客讲的也不错：[Java自定义类加载器与双亲委派模型](https://www.cnblogs.com/wxd0108/p/6681618.html)

   >父类结构大致如下：
   >
   >根类加载器  <-- 扩展类加载器  <-- 系统类加载器  <-- 用户类加载器
   >
   >
   >
   >双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
   >
   >
   >
   >双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

3. 缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。

   > 对于这个修改java文件后，必须重启才能生效，开发过程中有用过一个工具包，根据这里的意思大概猜到工具包的做法应该是检测到文件修改后，调用类加载器重新加载，而不是重启应用程序。
   >
   > 后来spring boot出来后，可以通过maven构建的形式，在pom.xml中引入
   >
   > ```
   > <dependency>
   > 	<groupId>org.springframework.boot</groupId>
   > 	<artifactId>spring-boot-devtools</artifactId>
   > </dependency>
   > ```
   >
   > 来达到自动重启、修改就生效的目的

